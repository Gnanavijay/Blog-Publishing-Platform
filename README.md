Mitt Arv - Blog Publishing PlatformProject OverviewThis is a full-stack blog publishing platform built for the Mitt Arv Software Engineering Internship assignment. It allows users to create, read, update, and delete blog posts. The project features a React frontend, a Node.js (Express) backend, and utilizes Supabase for the database and authentication.Core FeaturesAuthentication: Secure user signup and login using email/password via Supabase Auth.JWT Sessions: Session handling is managed by Supabase, ensuring secure API access.Blog Post CRUD: Full capabilities for users to Create, Read, Update, and Delete their own blog posts.Author Profiles: A simple profile page displaying a user's posts.Tech StackFrontend: React, Redux ToolkitBackend: Node.js, ExpressDatabase & Auth: SupabaseDeployment: Frontend on Netlify, Backend on Render.Setup and InstallationFollow the detailed instructions in the deployment_guide.md file to set up Supabase, deploy the backend on Render, and the frontend on Netlify.Local DevelopmentClone the repository:git clone <your-repo-url>
cd mitt-arv-blog
Backend Setup:cd server
npm install
# Create a .env file and add your Supabase URL and Key
# SUPABASE_URL=your_supabase_url
# SUPABASE_KEY=your_supabase_anon_key
npm start
Frontend Setup:cd client
npm install
# Create a .env file and add your backend URL
# REACT_APP_API_URL=http://localhost:3001
npm start
Use of AI Tools in DevelopmentAI tools were leveraged throughout the development process to improve efficiency and code quality.Tool Used: GitHub Copilot & GeminiPrompting Techniques & How AI HelpedBoilerplate Code Generation:Prompt Example: "Create a React functional component for a login form with email and password fields."How it helped: AI quickly generated the basic structure for React components and Node.js Express routes, including form elements and basic API endpoint structures (app.get, app.post, etc.). This saved significant time on repetitive setup tasks.Redux Toolkit Slice Implementation:Prompt Example: "Write a Redux Toolkit slice for handling blog posts, including async thunks for fetchPosts, createPost, and fetchPostById using Supabase."How it helped: This was one of the most useful applications. AI generated the complete slice, including the createSlice call, initial state, reducers, and correctly structured createAsyncThunk functions. It correctly inferred the need for pending, fulfilled, and rejected action types, which is a complex part of Redux setup.Debugging and Problem Solving:Prompt Example: "My useEffect hook is causing an infinite loop when fetching data. Here is the code: [code snippet]. How can I fix this?"How it helped: AI was instrumental in identifying issues with dependency arrays in useEffect hooks, a common source of bugs in React. It provided clear explanations and the corrected code, speeding up the debugging process significantly.Challenges FacedOverly Generic Code: Initially, prompts that were too vague ("make a blog backend") resulted in code that wasn't tailored to the specific database (Supabase) or state management (Redux Toolkit) being used.Solution: Prompts had to be made more specific, mentioning the exact libraries and desired functionality (e.g., "using Supabase rpc calls" or "for a Redux Toolkit extraReducers").Integrating AI with Existing Code: When asking the AI to add a feature to an existing file, it would sometimes lose the context of the rest of the application.Solution: Providing the entire file's code as context for the prompt, along with a clear instruction like "Add a function to handle post deletion to this existing Express server file," yielded much better results.